# -*- coding: utf-8 -*-
"""Resolvedor de Labirinto com Plotagem

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pIRJ_7dWlhcVKHFS8IL_d0WU9B4v61NY
"""

import collections
import matplotlib.pyplot as plt
import numpy as np

# Função que resolve o labirinto usando Busca em Largura (BFS)
def resolver_labirinto(labirinto):
    """
    Resolve um labirinto usando Busca em Largura (BFS) e retorna:
    - O caminho correto da entrada até a saída
    - Os caminhos errados (tentativas de caminhos explorados)
    - O labirinto original
    - Instantâneos das células exploradas durante a busca (para plotagem)
    """
    linhas = len(labirinto)  # Obtém o número de linhas do labirinto
    colunas = len(labirinto[0])  # Obtém o número de colunas do labirinto

    # Encontrando as posições da entrada ('E') e da saída ('S')
    entrada = None
    saida = None
    for r in range(linhas):  # Percorrendo as linhas
        for c in range(colunas):  # Percorrendo as colunas
            if labirinto[r][c] == 'E':  # Se encontrar a entrada
                entrada = (r, c)
            elif labirinto[r][c] == 'S':  # Se encontrar a saída
                saida = (r, c)

    if not entrada or not saida:  # Verifica se a entrada ou saída não foi encontrada
        print("Erro: Entrada ou Saída não encontradas no labirinto.")  # Mensagem de erro
        return None, [], labirinto, []  # Retorna erro

    # Fila de BFS com a posição da entrada e o caminho atual
    fila = collections.deque([(entrada[0], entrada[1], [entrada])])

    # Conjunto para armazenar as células já visitadas e evitar ciclos
    visitados = set([entrada])

    caminho_correto = None
    all_explored_paths_segments = []  # Lista para armazenar todos os caminhos explorados

    # Lista para capturar os estados das células visitadas ao longo da busca (usado para plotagem)
    exploration_snapshots = []
    snapshot_interval = 5  # Intervalo para capturar instantâneos após cada 5 células exploradas

    step_counter = 0  # Contador de passos para controle do intervalo de captura

    while fila:
        r_atual, c_atual, caminho_atual = fila.popleft()  # Pega a próxima célula da fila

        all_explored_paths_segments.append(caminho_atual)  # Armazena o caminho atual explorado

        # Captura de instantâneos para visualização da propagação da "onda de exploração"
        if step_counter % snapshot_interval == 0 or (r_atual, c_atual) == saida:
            exploration_snapshots.append(set(visitados))  # Adiciona o estado atual das células visitadas
        step_counter += 1

        # Verifica se chegou à saída, caso sim, encerra a busca
        if (r_atual, c_atual) == saida:
            caminho_correto = caminho_atual
            if set(visitados) not in exploration_snapshots:
                 exploration_snapshots.append(set(visitados))  # Captura o último estado
            break  # Interrompe o loop

        # Direções possíveis: (cima, baixo, esquerda, direita)
        direcoes = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        for dr, dc in direcoes:
            r_novo, c_novo = r_atual + dr, c_atual + dc

            # Verifica se a nova posição é válida e não visitada
            if (0 <= r_novo < linhas and 0 <= c_novo < colunas and
                labirinto[r_novo][c_novo] != '#' and  # A célula não deve ser uma parede
                (r_novo, c_novo) not in visitados):  # A célula não foi visitada

                visitados.add((r_novo, c_novo))  # Marca a célula como visitada
                novo_caminho = list(caminho_atual)  # Copia o caminho atual
                novo_caminho.append((r_novo, c_novo))  # Adiciona a nova célula ao caminho
                fila.append((r_novo, c_novo, novo_caminho))  # Adiciona à fila para exploração

    # Filtra os caminhos errados (tentativas que não chegaram à saída)
    caminhos_errados = []
    if caminho_correto:
        caminho_correto_set = set(caminho_correto)
        for path_segment in all_explored_paths_segments:
            is_wrong_path_segment = False
            for point in path_segment:
                if point not in caminho_correto_set:  # Se o ponto não faz parte do caminho correto
                    is_wrong_path_segment = True
                    break

            if is_wrong_path_segment and path_segment != caminho_correto:
                caminhos_errados.append(path_segment)  # Adiciona os caminhos errados
    else:
        caminhos_errados = [path for path in all_explored_paths_segments if len(path) > 1]  # Adiciona caminhos errados

    return caminho_correto, caminhos_errados, labirinto, exploration_snapshots


# Função para plotar um instantâneo do labirinto, mostrando as células visitadas
def plotar_labirinto_snapshot(labirinto, visited_cells, step_title, entry_exit_coords):
    """
    Plota um instantâneo do labirinto, mostrando as células visitadas até o momento.
    """
    linhas = len(labirinto)
    colunas = len(labirinto[0])
    entrada, saida = entry_exit_coords

    maze_matrix = np.zeros((linhas, colunas))  # Cria uma matriz inicializada com zeros (caminho livre)

    # Preenche a matriz com valores para as paredes, entrada e saída
    for r in range(linhas):
        for c in range(colunas):
            if labirinto[r][c] == '#':  # Se for uma parede
                maze_matrix[r][c] = 1  # Marca como 1 (parede)
            elif (r, c) == entrada:  # Se for a entrada
                maze_matrix[r][c] = 2  # Marca como 2 (entrada)
            elif (r, c) == saida:  # Se for a saída
                maze_matrix[r][c] = 3  # Marca como 3 (saída)
            elif (r, c) in visited_cells:  # Se a célula foi visitada
                maze_matrix[r][c] = 4  # Marca como 4 (célula visitada)
            else:
                maze_matrix[r][c] = 0  # Marca como 0 (caminho livre)

    # Definir as cores para o gráfico (correspondente a cada valor da matriz)
    cmap = plt.cm.colors.ListedColormap(['white', 'black', 'blue', 'darkgreen', 'cyan'])
    bounds = [-0.5, 0.5, 1.5, 2.5, 3.5, 4.5]  # Limites de cada cor
    norm = plt.cm.colors.BoundaryNorm(bounds, cmap.N)  # Normaliza as cores para os valores

    # Criação do gráfico
    fig, ax = plt.subplots(figsize=(colunas * 0.5, linhas * 0.5))  # Ajusta o tamanho do gráfico
    ax.imshow(maze_matrix, cmap=cmap, norm=norm)

    ax.set_xticks(np.arange(-.5, colunas, 1), minor=True)  # Adiciona as linhas de grade
    ax.set_yticks(np.arange(-.5, linhas, 1), minor=True)  # Adiciona as colunas de grade
    ax.grid(which="minor", color="gray", linestyle='-', linewidth=1)  # Define o estilo da grade
    ax.tick_params(which="minor", size=0)  # Remove os marcadores dos eixos

    ax.set_xticks([])  # Remove as marcas de eixos X
    ax.set_yticks([])  # Remove as marcas de eixos Y

    # Título do gráfico
    ax.set_title(f"Propagação da Onda de Exploração (Passo: {step_title})")

    # Adiciona a legenda para os diferentes elementos do labirinto
    legend_elements = [
        plt.Line2D([0], [0], marker='s', color='w', label='Caminho Livre', markerfacecolor='white', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Parede', markerfacecolor='black', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Entrada', markerfacecolor='blue', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Saída', markerfacecolor='darkgreen', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Célula Explorada', markerfacecolor='cyan', markersize=10)
    ]
    ax.legend(handles=legend_elements, bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)

    plt.tight_layout()  # Ajusta o layout do gráfico para não cortar nada
    plt.show()  # Exibe o gráfico
    plt.close(fig)  # Fecha a figura para liberar recursos

# Função para plotar o labirinto final com o caminho correto
def plotar_labirinto_final(labirinto, caminho_correto=None, caminhos_errados=None, final_visited_cells=None):
    """
    Plota o labirinto final, destacando o caminho correto e os caminhos errados explorados.
    """
    linhas = len(labirinto)
    colunas = len(labirinto[0])

    maze_matrix = np.zeros((linhas, colunas))  # Cria uma matriz inicializada com zeros (caminho livre)

    # Preenche a matriz com valores para as paredes, entrada e saída
    for r in range(linhas):
        for c in range(colunas):
            if labirinto[r][c] == '#':
                maze_matrix[r][c] = 1  # Parede
            elif labirinto[r][c] == 'E':
                maze_matrix[r][c] = 2  # Entrada
            elif labirinto[r][c] == 'S':
                maze_matrix[r][c] = 3  # Saída
            else:
                maze_matrix[r][c] = 0  # Caminho livre

    # Preencher as células exploradas (em vermelho) e o caminho correto (em verde claro)
    if final_visited_cells:
        for r, c in final_visited_cells:
            if maze_matrix[r][c] == 0:  # Não sobrescrever entradas/saídas
                maze_matrix[r][c] = 5  # Explorado mas não correto (vermelho)

    if caminho_correto:
        for r, c in caminho_correto:
            if maze_matrix[r][c] == 0 or maze_matrix[r][c] == 5:
                maze_matrix[r][c] = 4  # Caminho correto (verde claro)

    # Definir o mapa de cores
    cmap = plt.cm.colors.ListedColormap(['white', 'black', 'blue', 'darkgreen', 'lightgreen', 'red'])
    bounds = [-0.5, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5]
    norm = plt.cm.colors.BoundaryNorm(bounds, cmap.N)

    # Plotando a matriz do labirinto final
    fig, ax = plt.subplots(figsize=(colunas * 0.5, linhas * 0.5))
    ax.imshow(maze_matrix, cmap=cmap, norm=norm)

    ax.set_xticks(np.arange(-.5, colunas, 1), minor=True)
    ax.set_yticks(np.arange(-.5, linhas, 1), minor=True)
    ax.grid(which="minor", color="gray", linestyle='-', linewidth=1)
    ax.tick_params(which="minor", size=0)

    ax.set_xticks([])  # Remove as marcas de eixos X
    ax.set_yticks([])  # Remove as marcas de eixos Y

    ax.set_title("Resolução Final do Labirinto")  # Título do gráfico

    # Adiciona a legenda para o gráfico final
    legend_elements = [
        plt.Line2D([0], [0], marker='s', color='w', label='Caminho Livre', markerfacecolor='white', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Parede', markerfacecolor='black', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Entrada', markerfacecolor='blue', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Saída', markerfacecolor='darkgreen', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Caminho Correto', markerfacecolor='lightgreen', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Caminho Errado', markerfacecolor='red', markersize=10)
    ]
    ax.legend(handles=legend_elements, bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)

    plt.tight_layout()  # Ajusta o layout do gráfico para não cortar nada
    plt.show()  # Exibe o gráfico
    plt.close(fig)  # Fecha a figura para liberar recursos

# Testando o labirinto e a solução
entrada_coords = None
saida_coords = None
for r in range(len(labirinto_com_saida)):
    for c in range(len(labirinto_com_saida[0])):
        if labirinto_com_saida[r][c] == 'E':
            entrada_coords = (r, c)
        elif labirinto_com_saida[r][c] == 'S':
            saida_coords = (r, c)

entry_exit_coords = (entrada_coords, saida_coords)

# Resolver o labirinto e obter os instantâneos de cada etapa
caminho_correto, caminhos_errados_encontrados, labirinto_original, exploration_snapshots = resolver_labirinto(labirinto_com_saida)

# Gerar os gráficos de demonstração da propagação do caminho
for i, visited_set_at_step in enumerate(exploration_snapshots):
    plotar_labirinto_snapshot(labirinto_original, visited_set_at_step, i + 1, entry_exit_coords)

# Plotar a solução final
if caminho_correto:
    plotar_labirinto_final(labirinto_original, caminho_correto, caminhos_errados_encontrados, exploration_snapshots[-1])