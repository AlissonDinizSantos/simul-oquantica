# -*- coding: utf-8 -*-
"""reslvlabirinto.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17nkwpR0N-BqwyjHHGKc0csJnqSWt3TIm
"""

import collections
import matplotlib.pyplot as plt
import numpy as np

# Labirinto com entrada 'E' e saída 'S'
labirinto_complexo = [
    list("####################"),
    list("E  #       #       #"),
    list("#  ### ### # # ### #"),
    list("#    # #   # # #   #"),
    list("###  # ### # # # ###"),
    list("#    # #   #   #   #"),
    list("# #### ####### #####"),
    list("#      #   # #     #"),
    list("#### ### # # # #####"),
    list("#    #   # # #     #"),
    list("# #### ##### ### ###"),
    list("#  #   # #   # #   #"),
    list("## ### # # # ### ###"),
    list("#  #   #   #   #   #"),
    list("#  ########### ### #"),
    list("#      #       #   #"),
    list("### ########## ### #"),
    list("#   #          #   S"),
    list("####################"),
]

def resolver_labirinto(labirinto):
    """
    Resolve um labirinto usando Busca em Largura (BFS) e retorna
    o caminho correto, os caminhos explorados (incluindo os errados),
    o labirinto original, e uma lista de estados de exploração para plotagem.
    """
    linhas = len(labirinto)  # Número de linhas do labirinto
    colunas = len(labirinto[0])  # Número de colunas do labirinto

    # Encontrar entrada e saída no labirinto
    entrada = None
    saida = None
    for r in range(linhas):  # Percorre as linhas
        for c in range(colunas):  # Percorre as colunas
            if labirinto[r][c] == 'E':  # Se encontrar a entrada
                entrada = (r, c)
            elif labirinto[r][c] == 'S':  # Se encontrar a saída
                saida = (r, c)

    if not entrada or not saida:  # Se não encontrar entrada ou saída
        print("Erro: Entrada ou Saída não encontradas no labirinto.")
        return None, [], labirinto, []

    # Fila para BFS: Armazenando (linha, coluna, caminho_atual)
    fila = collections.deque([(entrada[0], entrada[1], [entrada])])

    # Conjunto para rastrear células visitadas para evitar ciclos
    visitados = set([entrada])  # Marcar a entrada como visitada

    caminho_correto = None
    all_explored_paths_segments = []  # Lista para armazenar os segmentos de caminhos explorados

    # Lista para armazenar instantâneos do conjunto de células visitadas
    exploration_snapshots = []
    exploration_snapshots.append(set(visitados))  # Captura do estado inicial
    snapshot_interval = 5  # Captura um instantâneo a cada 5 células visitadas

    step_counter = 0

    while fila:
        r_atual, c_atual, caminho_atual = fila.popleft()  # Pegando a célula da frente da fila

        all_explored_paths_segments.append(caminho_atual)  # Armazenando o caminho explorado

        # Se chegamos na saída, encontramos o caminho correto
        if (r_atual, c_atual) == saida:
            caminho_correto = caminho_atual
            if set(visitados) not in exploration_snapshots:
                exploration_snapshots.append(set(visitados))  # Salvando o último estado
            break  # Interrompe a busca após encontrar a saída

        # Direções possíveis: Cima, Baixo, Esquerda, Direita
        direcoes = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        for dr, dc in direcoes:
            r_novo, c_novo = r_atual + dr, c_atual + dc

            # Verifica se a nova posição é válida e ainda não foi visitada
            if (0 <= r_novo < linhas and 0 <= c_novo < colunas and
                labirinto[r_novo][c_novo] != '#' and  # Se não for uma parede
                (r_novo, c_novo) not in visitados):  # Se não foi visitada

                visitados.add((r_novo, c_novo))  # Marca como visitada
                novo_caminho = list(caminho_atual)  # Copia o caminho atual
                novo_caminho.append((r_novo, c_novo))  # Adiciona a nova célula ao caminho
                fila.append((r_novo, c_novo, novo_caminho))  # Adiciona à fila para explorar

                # Captura instantâneo após cada adição
                if step_counter % snapshot_interval == 0:
                    exploration_snapshots.append(set(visitados))
                step_counter += 1

    # Garantir que o último estado de visita seja capturado
    if set(visitados) not in exploration_snapshots:
        exploration_snapshots.append(set(visitados))

    # Filtrando os caminhos errados
    caminhos_errados = []
    if caminho_correto:
        caminho_correto_set = set(caminho_correto)
        for path_segment in all_explored_paths_segments:
            is_wrong_path_segment = False
            for point in path_segment:
                if point not in caminho_correto_set:  # Se o ponto não faz parte do caminho correto
                    is_wrong_path_segment = True
                    break
            if is_wrong_path_segment and path_segment != caminho_correto:  # Se for um caminho errado
                caminhos_errados.append(path_segment)  # Adiciona caminhos errados
    else:
        caminhos_errados = [path for path in all_explored_paths_segments if len(path) > 1]  # Caminhos errados se não houver caminho correto

    return caminho_correto, caminhos_errados, labirinto, exploration_snapshots


# Função para plotar instantâneos do labirinto com as células visitadas
def plotar_labirinto_snapshot(labirinto, visited_cells, step_title, entry_exit_coords):
    """
    Plota um instantâneo do labirinto, mostrando as células visitadas até o momento.
    """
    linhas = len(labirinto)
    colunas = len(labirinto[0])
    entrada, saida = entry_exit_coords

    maze_matrix = np.zeros((linhas, colunas))  # Inicializa a matriz do labirinto

    # Preenchendo a matriz do labirinto com os valores apropriados
    for r in range(linhas):
        for c in range(colunas):
            if labirinto[r][c] == '#':
                maze_matrix[r][c] = 1  # Parede
            elif (r, c) == entrada:
                maze_matrix[r][c] = 2  # Entrada
            elif (r, c) == saida:
                maze_matrix[r][c] = 3  # Saída
            elif (r, c) in visited_cells:
                maze_matrix[r][c] = 4  # Célula visitada (onda de exploração)
            else:
                maze_matrix[r][c] = 0  # Caminho livre

    # Definir mapa de cores para o instantâneo
    cmap = plt.cm.colors.ListedColormap(['white', 'black', 'blue', 'darkgreen', 'cyan'])
    bounds = [-0.5, 0.5, 1.5, 2.5, 3.5, 4.5]
    norm = plt.cm.colors.BoundaryNorm(bounds, cmap.N)

    # Plotando a matriz do labirinto
    fig, ax = plt.subplots(figsize=(colunas * 0.6, linhas * 0.6))  # Aumenta o tamanho da figura
    ax.imshow(maze_matrix, cmap=cmap, norm=norm)

    # Adicionando a grade e removendo as marcas dos eixos
    ax.set_xticks(np.arange(-.5, colunas, 1), minor=True)
    ax.set_yticks(np.arange(-.5, linhas, 1), minor=True)
    ax.grid(which="minor", color="gray", linestyle='-', linewidth=1)
    ax.tick_params(which="minor", size=0)

    ax.set_xticks([])  # Remove as marcas dos eixos
    ax.set_yticks([])

    # Título para o gráfico
    ax.set_title(f"Propagação da Onda de Exploração (Passo: {step_title})")

    # Adicionando legenda para o instantâneo
    legend_elements = [
        plt.Line2D([0], [0], marker='s', color='w', label='Caminho Livre', markerfacecolor='white', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Parede', markerfacecolor='black', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Entrada', markerfacecolor='blue', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Saída', markerfacecolor='darkgreen', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Célula Explorada', markerfacecolor='cyan', markersize=10)
    ]
    ax.legend(handles=legend_elements, bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)

    plt.tight_layout()
    plt.show()
    plt.close(fig)


# Função para plotar o labirinto final com os resultados (caminho correto e caminhos errados)
def plotar_labirinto_final(labirinto, caminho_correto=None, caminhos_errados=None, final_visited_cells=None):
    """
    Plota o labirinto com o caminho correto e os caminhos errados finais.
    """
    linhas = len(labirinto)
    colunas = len(labirinto[0])

    maze_matrix = np.zeros((linhas, colunas))

    # Preenchendo a matriz do labirinto com os valores apropriados
    for r in range(linhas):
        for c in range(colunas):
            if labirinto[r][c] == '#':
                maze_matrix[r][c] = 1  # Parede
            elif labirinto[r][c] == 'E':
                maze_matrix[r][c] = 2  # Entrada
            elif labirinto[r][c] == 'S':
                maze_matrix[r][c] = 3  # Saída
            else:
                maze_matrix[r][c] = 0  # Caminho livre

    # Preencher todas as células visitadas
    if final_visited_cells:
        for r, c in final_visited_cells:
            if maze_matrix[r][c] == 0:
                maze_matrix[r][c] = 5  # Células exploradas (vermelho)

    # Marcar o caminho correto
    if caminho_correto:
        for r, c in caminho_correto:
            if maze_matrix[r][c] == 0 or maze_matrix[r][c] == 5:
                maze_matrix[r][c] = 4  # Caminho correto (verde claro)

    # Definir mapa de cores para o resultado final
    cmap = plt.cm.colors.ListedColormap(['white', 'black', 'blue', 'darkgreen', 'lightgreen', 'red'])
    bounds = [-0.5, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5]
    norm = plt.cm.colors.BoundaryNorm(bounds, cmap.N)

    # Plotando a matriz do labirinto final
    fig, ax = plt.subplots(figsize=(colunas * 0.6, linhas * 0.6))
    ax.imshow(maze_matrix, cmap=cmap, norm=norm)

    # Adicionando a grade e removendo as marcas dos eixos
    ax.set_xticks(np.arange(-.5, colunas, 1), minor=True)
    ax.set_yticks(np.arange(-.5, linhas, 1), minor=True)
    ax.grid(which="minor", color="gray", linestyle='-', linewidth=1)
    ax.tick_params(which="minor", size=0)

    ax.set_xticks([])  # Remove as marcas dos eixos
    ax.set_yticks([])

    # Título para o gráfico final
    ax.set_title("Resolução Final do Labirinto")

    # Adicionando legenda para o gráfico final
    legend_elements = [
        plt.Line2D([0], [0], marker='s', color='w', label='Caminho Livre', markerfacecolor='white', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Parede', markerfacecolor='black', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Entrada', markerfacecolor='blue', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Saída', markerfacecolor='darkgreen', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Caminho Correto', markerfacecolor='lightgreen', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Caminho Errado', markerfacecolor='red', markersize=10)
    ]
    ax.legend(handles=legend_elements, bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)

    plt.tight_layout()
    plt.show()
    plt.close(fig)


# Resolver e plotar o labirinto
entrada_coords = None
saida_coords = None
for r in range(len(labirinto_complexo)):
    for c in range(len(labirinto_complexo[0])):
        if labirinto_complexo[r][c] == 'E':
            entrada_coords = (r, c)
        elif labirinto_complexo[r][c] == 'S':
            saida_coords = (r, c)
entry_exit_coords = (entrada_coords, saida_coords)

# Resolver o labirinto e gerar instantâneos
caminho_correto, caminhos_errados_encontrados, labirinto_original, exploration_snapshots = resolver_labirinto(labirinto_complexo)

# Plotar os instantâneos durante a propagação
for i, visited_set_at_step in enumerate(exploration_snapshots):
    plotar_labirinto_snapshot(labirinto_original, visited_set_at_step, i + 1, entry_exit_coords)

# Plotar o labirinto final com o caminho correto
if caminho_correto:
    plotar_labirinto_final(labirinto_original, caminho_correto, caminhos_errados_encontrados, exploration_snapshots[-1])