# -*- coding: utf-8 -*-
"""reslvlabirinto.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17nkwpR0N-BqwyjHHGKc0csJnqSWt3TIm
"""

import collections
import matplotlib.pyplot as plt
import numpy as np

def resolver_labirinto(labirinto):
    """
    Resolve um labirinto usando Busca em Largura (BFS) e retorna
    o caminho correto, os caminhos explorados (incluindo os errados),
    o labirinto original, e uma lista de estados de exploração para plotagem.
    """
    linhas = len(labirinto)
    colunas = len(labirinto[0])

    # Encontrar entrada e saída
    entrada = None
    saida = None
    for r in range(linhas):
        for c in range(colunas):
            if labirinto[r][c] == 'E':
                entrada = (r, c)
            elif labirinto[r][c] == 'S':
                saida = (r, c)

    if not entrada or not saida:
        print("Erro: Entrada ou Saída não encontradas no labirinto.")
        return None, [], labirinto, []

    # Fila para BFS: (linha, coluna, caminho_atual)
    fila = collections.deque([(entrada[0], entrada[1], [entrada])])

    # Conjunto para rastrear células visitadas para evitar ciclos
    visitados = set([entrada])

    caminho_correto = None
    all_explored_paths_segments = []

    # Lista para armazenar instantâneos do conjunto de células visitadas
    # para demonstrar a propagação da "onda de exploração"
    exploration_snapshots = []
    snapshot_interval = 5 # Capturar um instantâneo a cada 5 células visitadas

    step_counter = 0

    while fila:
        r_atual, c_atual, caminho_atual = fila.popleft()

        all_explored_paths_segments.append(caminho_atual)

        # Captura de instantâneos para visualização da "onda de exploração"
        if step_counter % snapshot_interval == 0 or (r_atual, c_atual) == saida:
            exploration_snapshots.append(set(visitados)) # Adiciona uma cópia do conjunto visitados
        step_counter += 1

        # Se chegamos na saída, encontramos o caminho correto
        if (r_atual, c_atual) == saida:
            caminho_correto = caminho_atual
            # Garante que o último instantâneo inclua o caminho final
            if set(visitados) not in exploration_snapshots:
                 exploration_snapshots.append(set(visitados))
            break

        # Direções: (dr, dc) para (cima, baixo, esquerda, direita)
        direcoes = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        for dr, dc in direcoes:
            r_novo, c_novo = r_atual + dr, c_atual + dc

            # Verificar se a nova posição é válida
            if (0 <= r_novo < linhas and 0 <= c_novo < colunas and
                labirinto[r_novo][c_novo] != '#' and
                (r_novo, c_novo) not in visitados):

                visitados.add((r_novo, c_novo))
                novo_caminho = list(caminho_atual)
                novo_caminho.append((r_novo, c_novo))
                fila.append((r_novo, c_novo, novo_caminho))

    # Filtrar caminhos explorados para identificar os caminhos "errados"
    caminhos_errados = []
    if caminho_correto:
        caminho_correto_set = set(caminho_correto)
        for path_segment in all_explored_paths_segments:
            is_wrong_path_segment = False
            for point in path_segment:
                if point not in caminho_correto_set:
                    is_wrong_path_segment = True
                    break

            if is_wrong_path_segment and path_segment != caminho_correto:
                caminhos_errados.append(path_segment)
    else:
        caminhos_errados = [path for path in all_explored_paths_segments if len(path) > 1]

    return caminho_correto, caminhos_errados, labirinto, exploration_snapshots

def plotar_labirinto_snapshot(labirinto, visited_cells, step_title, entry_exit_coords):
    """
    Plota um instantâneo do labirinto, mostrando as células visitadas até o momento.
    """
    linhas = len(labirinto)
    colunas = len(labirinto[0])
    entrada, saida = entry_exit_coords

    maze_matrix = np.zeros((linhas, colunas))

    for r in range(linhas):
        for c in range(colunas):
            if labirinto[r][c] == '#':
                maze_matrix[r][c] = 1  # Parede
            elif (r, c) == entrada:
                maze_matrix[r][c] = 2  # Entrada
            elif (r, c) == saida:
                maze_matrix[r][c] = 3  # Saída
            elif (r, c) in visited_cells:
                maze_matrix[r][c] = 4  # Célula visitada (onda de exploração)
            else:
                maze_matrix[r][c] = 0  # Caminho livre

    # Definir mapa de cores para o instantâneo
    # 0: Branco (caminho livre)
    # 1: Preto (paredes)
    # 2: Azul (entrada)
    # 3: Verde Escuro (saída)
    # 4: Ciano (células visitadas/onda de exploração)
    cmap = plt.cm.colors.ListedColormap(['white', 'black', 'blue', 'darkgreen', 'cyan'])
    bounds = [-0.5, 0.5, 1.5, 2.5, 3.5, 4.5]
    norm = plt.cm.colors.BoundaryNorm(bounds, cmap.N)

    fig, ax = plt.subplots(figsize=(colunas * 0.5, linhas * 0.5))
    ax.imshow(maze_matrix, cmap=cmap, norm=norm)

    ax.set_xticks(np.arange(-.5, colunas, 1), minor=True)
    ax.set_yticks(np.arange(-.5, linhas, 1), minor=True)
    ax.grid(which="minor", color="gray", linestyle='-', linewidth=1)
    ax.tick_params(which="minor", size=0)

    ax.set_xticks([])
    ax.set_yticks([])

    ax.set_title(f"Propagação da Onda de Exploração (Passo: {step_title})")

    # Adicionar legenda para o instantâneo
    legend_elements = [
        plt.Line2D([0], [0], marker='s', color='w', label='Caminho Livre', markerfacecolor='white', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Parede', markerfacecolor='black', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Entrada', markerfacecolor='blue', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Saída', markerfacecolor='darkgreen', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Célula Explorada', markerfacecolor='cyan', markersize=10)
    ]
    ax.legend(handles=legend_elements, bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)

    plt.tight_layout()
    plt.show()
    plt.close(fig)

def plotar_labirinto_final(labirinto, caminho_correto=None, caminhos_errados=None, final_visited_cells=None):
    """
    Plota o labirinto com o caminho correto e os caminhos errados finais.
    """
    linhas = len(labirinto)
    colunas = len(labirinto[0])

    maze_matrix = np.zeros((linhas, colunas))

    for r in range(linhas):
        for c in range(colunas):
            if labirinto[r][c] == '#':
                maze_matrix[r][c] = 1  # Parede
            elif labirinto[r][c] == 'E':
                maze_matrix[r][c] = 2  # Entrada
            elif labirinto[r][c] == 'S':
                maze_matrix[r][c] = 3  # Saída
            else:
                maze_matrix[r][c] = 0  # Caminho livre

    # Primeiro, preencher todas as células visitadas (que não são entrada/saída/parede) como "exploradas" (vermelho)
    if final_visited_cells:
        for r, c in final_visited_cells:
            # Não sobrescrever entrada/saída/paredes
            if maze_matrix[r][c] == 0: # Marcar apenas se for um caminho livre
                maze_matrix[r][c] = 5  # Explorado mas não correto (vermelho)

    # Marcar caminho correto (sobrepondo os caminhos errados se houver)
    if caminho_correto:
        for r, c in caminho_correto:
            # Não sobrescrever entrada/saída, mas pode sobrescrever um caminho explorado
            if maze_matrix[r][c] == 0 or maze_matrix[r][c] == 5:
                maze_matrix[r][c] = 4  # Caminho correto (verde claro)

    # Definir mapa de cores para o resultado final
    # 0: Branco (caminho livre)
    # 1: Preto (paredes)
    # 2: Azul (entrada)
    # 3: Verde Escuro (saída)
    # 4: Verde Claro (caminho correto)
    # 5: Vermelho (caminhos errados)
    cmap = plt.cm.colors.ListedColormap(['white', 'black', 'blue', 'darkgreen', 'lightgreen', 'red'])
    bounds = [-0.5, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5]
    norm = plt.cm.colors.BoundaryNorm(bounds, cmap.N)

    fig, ax = plt.subplots(figsize=(colunas * 0.5, linhas * 0.5))
    ax.imshow(maze_matrix, cmap=cmap, norm=norm)

    ax.set_xticks(np.arange(-.5, colunas, 1), minor=True)
    ax.set_yticks(np.arange(-.5, linhas, 1), minor=True)
    ax.grid(which="minor", color="gray", linestyle='-', linewidth=1)
    ax.tick_params(which="minor", size=0)

    ax.set_xticks([])
    ax.set_yticks([])

    ax.set_title("Resolução Final do Labirinto")

    legend_elements = [
        plt.Line2D([0], [0], marker='s', color='w', label='Caminho Livre', markerfacecolor='white', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Parede', markerfacecolor='black', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Entrada', markerfacecolor='blue', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Saída', markerfacecolor='darkgreen', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Caminho Correto', markerfacecolor='lightgreen', markersize=10),
        plt.Line2D([0], [0], marker='s', color='w', label='Caminho Errado', markerfacecolor='red', markersize=10)
    ]
    ax.legend(handles=legend_elements, bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)

    plt.tight_layout()
    plt.show()
    plt.close(fig)

# --- Labirinto de Exemplo (Modificado para ter um caminho contínuo) ---
labirinto_com_saida = [
    list("####################"),
    list("E                  #"), # Caminho aberto
    list("# ####### #######  #"),
    list("# #              # #"), # Caminho aberto
    list("#   ####### ####   #"), # Caminho aberto
    list("# #     #     # #  #"), # Caminho aberto
    list("# ## #### ### # #  #"),
    list("#     #     #    # #"), # Caminho aberto
    list("##### ### ### #  # #"),
    list("#     #     #    # #"), # Caminho aberto
    list("# ###### ########  # #"),
    list("#                #  #"), # Caminho aberto
    list("# ########### #####  #"),
    list("#             #      #"), # Caminho aberto
    list("# #############      #"), # Caminho aberto
    list("#                  S #"), # Caminho aberto
    list("####################")
]

# Encontrar entrada e saída para passar para a função de plotagem de instantâneo
entrada_coords = None
saida_coords = None
for r in range(len(labirinto_com_saida)):
    for c in range(len(labirinto_com_saida[0])):
        if labirinto_com_saida[r][c] == 'E':
            entrada_coords = (r, c)
        elif labirinto_com_saida[r][c] == 'S':
            saida_coords = (r, c)
entry_exit_coords = (entrada_coords, saida_coords)


# Resolver o labirinto e obter instantâneos
caminho_correto, caminhos_errados_encontrados, labirinto_original, exploration_snapshots = resolver_labirinto(labirinto_com_saida)

# --- Gerar gráficos de demonstração da "onda de exploração" ---
print("--- Demonstração Conceitual de Máquina Quântica de Turing (Propagação da Onda de Exploração) ---")
for i, visited_set_at_step in enumerate(exploration_snapshots):
    plotar_labirinto_snapshot(labirinto_original, visited_set_at_step, i + 1, entry_exit_coords)

# --- Plotar o labirinto com os resultados finais ---
if caminho_correto:
    print("\n--- Resultados da Simulação (Visão Final) ---")
    print(f"Comprimento do caminho correto: {len(caminho_correto) - 1} passos")
    # Passa o último instantâneo de células visitadas para plotar o preenchimento
    plotar_labirinto_final(labirinto_original, caminho_correto, caminhos_errados_encontrados, exploration_snapshots[-1])

    print("\nCaminhos Errados Possíveis (Marcados em Vermelho na Plotagem Final):")
    if caminhos_errados_encontrados:
        for i, caminho in enumerate(caminhos_errados_encontrados):
            # Imprime apenas os primeiros 5 caminhos errados para não sobrecarregar a saída
            if i < 5:
                print(f"  Caminho Errado {i+1}: {caminho}")
            elif i == 5:
                print("  (Mais caminhos errados existem, mas foram omitidos para brevidade)")
    else:
        print("  Nenhum caminho explicitamente 'errado' foi detectado que não seja um subconjunto do caminho correto.")
else:
    print("\nNão foi possível encontrar um caminho da entrada para a saída neste labirinto.")
    # Passa o último instantâneo de células visitadas para plotar o preenchimento
    plotar_labirinto_final(labirinto_original, final_visited_cells=exploration_snapshots[-1] if exploration_snapshots else None)